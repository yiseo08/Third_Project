<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>프로젝트3의 기본원리 ..</title>
    </head>
    <body>
        <h1>동기와 비동기에 대한 간단한 이해</h1>
        <h2>1. 자바스크립트의 구성 요소</h2>
        <ul>
            <li>
                <h3>stack</h3>
                자바스크립트 코드가 실행되면 실행 될 명령들(스택 프레임)이 쌓이는 장소. <br />
                스택에 새로운 프레임들이 들어오고 실행이 완료되면 나간다. <br />
                드럼통처럼 생겨서 First In Last Out 구조의 자료형이다. (먼저 들어온 것이 나중에 나가는 구조 ..) <br />
                <img src="./1_런타임(큐,스텍).png" alt="런타임" />
            </li>
            <li>
                <h3>Heap</h3>
                동적으로 생성된 변수들은 메모리 heap에 저장된다.
            </li>
            <li style="list-style: none; width: 700">
                <img src="./2_콜스텍.png" alt="콜스텍" />
            </li>
            <li>
                <h3>테스크 큐(Queue)</h3>
                웹 api로부터 받은 테스크를 큐에 저장해 둔다. <br />
                스택이 비워지면 이벤트 루프가 큐에 아이템을 꺼내다가 스택으로 올려준다. <br />
                First In First Out의 자료구조 형태이다. <br />
            </li>
            <li><img src="./3_큐.png" alt="큐" /></li>
            <li>
                <h3>Even Loop</h3>
                스택과 큐 사이에서 흐름을 제어한다. <br />
                이벤트 루프는 스택이 비어있는지를 확인하고, 비어있으면 큐에 있는 아이템을 꺼내다가 스택에 올려준다.
            </li>
            <li>
                <h3>웹 api</h3>
                Ajax 요청, setTimeOut(), 이벤트 핸들러의 등록과 같이 웹 브라우저에서 제공하는 기능들을 말한다. <br />
                이들은 자바스크립트의 쓰레드(스택)에서 작업이 이루어지는 것이 아닌 별도의 쓰레드에서 이루어진다.
            </li>
            <li>
                <h3>setTimeOut(함수, 시간)</h3>
                Ajax, Axios, fetch : 클라이언트와 서버 간에 데이터를 주고 받는 기술 <br />
                Event Handler : 클릭과 같은 이벤트를 핸들링 하는 함수들
            </li>
            <li>
                <h3>쓰레드(Thread)</h3>
                쓰레드란 실제로 작업을 실행하는 주체이다. <br />
                쓰레드는 한개이거나 여러개 일 수 있다. <br />
                자바스크립트는 싱글(1개)의 쓰레드만 있다. <br />
                쓰레드가 1개이면 하나씩 밖에 일처리를 못해서 동기적으로 일을 처리하게 된다. <br />
                멀티 쓰레드라면 (1개 이상) 여러개의 작업을 병렬적으로 처리할 수 있다. <br />
                자바스크립트는 싱글 쓰레드로 동기적 처리를 한다는 것을 필히 명심해야 한다.
            </li>
            <li>
                <h3>API를 부르는 방식</h3>
                ajax, axios, fetch가 있다. <br />
                이 중에서는 fetch가 제일 간단하다. <br />
                ajax, axios는 React.js에서 많이 사용되기도 한다.
            </li>
            <li>
                <h3>Promise</h3>
                자바스크립트에서 비동기 동작을 다루는 ES6 최신 문법이다. <br />
                기존에 콜백함수를 이용해서 비동기처리를 하였는데, <br />
                $.ajax("'http://api.newscatcher.com/v2/search", (result) => {console.log(result);}); <br />
                위의 코드와 같은 방식이라면 url이 호출되고, 결과가 나오면 두번째 매개변수인 콜백함수를 불러서 result에 결과값을 넘겨 줬다. <br />
                이렇게 하면 가독성이 많이 떨어진다.(콜백 지옥) <br />
                함수 안에 함수, 그 안에 또 함수, 또 함수, 함수 함수... <br />
                그래서 나온 것이 Promise이다. <br />
                function delayP(sec) { <br />
                &nbsp;&nbsp; return new Promise((resolve, reject) => { <br />
                &nbsp;&nbsp;&nbsp;&nbsp; setTimeout(() => { <br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resolve("success"); <br />
                &nbsp;&nbsp;&nbsp;&nbsp; }, sec * 1000); <br />
                &nbsp;&nbsp; }); <br />
                } <br />
                newPromise를 이용해서 promise를 생성하고, promise 안에서는 resolve와 reject 함수를 자동으로 가진다. <br />
                resolve는 결과가 문제 없이 성공적으로 수행될 때 호출하는 함수 <br />
                reject는 중간에 에러가 생기면 에러를 처리할 수 있는 함수 <br />
                resolve가 호출되면 콜백 대신에 .then()이나 async / await를 이용해서 그 결과값을 받아내 다른 일들을 할 수 있다.
            </li>
            <li>
                <h3>async / await</h3>
                async와 await는 동기적인 자바스크립트를 비동기적으로 처리하기 위해 사용한다. <br />
                fetch는 promise를 리턴한다. 그리고 우리가 필요한 건 그 promise 속에서 api 호출이 잘 이루어져 데이터를 받은 다음, promise가 성공적으로 resolve를 호출하기를 기다리는 것이다. <br />
                이걸 해주는 게 await이다. <br />
                await이 없으면 날 것 그대로의 promise가 리턴된다. <br />
                await을 쓰려면 함수를 async로 선언해야 한다. 즉 둘은 세트라고 생각하면 된다. <br />
                그 외에도 async로 함수를 선언하면, 그 함수는 자동으로 promise를 반환한다. 이 함수를 받아서 다른 비동기 작업이 가능하다는 이야기가 된다.<br />
            </li>
            <li>
                <h3>json</h3>
                서버 클라이언트 통신에서 많이 쓰이는 데이터 타입(png, jpg와 같은 데이터 타입) <br />
                객체와 똑같은 텍스트라고 이해하면 좋다. <br />
                간단한 텍스트인데 객체랑 똑같아 나중에 읽어오기도 매우 편하다. <br />
                그래서 json 타입을 서버 통신 시에 많이 사용한다.
            </li>
            <li>
                <h3>fetch를 사용할 때의 패턴</h3>
                let response = await fetch(url) <br />
                let daa = await response.json() <br />
                위에 쓰인 패턴은 세트로 많이 사용된다. 익숙해지면 좋다.
            </li>
            <li>
                <h3>API를 호출하고 싶을 때</h3>
                const callAPI = async() => { <br />
                &nbsp;&nbsp;&nbsp;&nbsp; let url = new URL(`url 주소`) <br />
                &nbsp;&nbsp;&nbsp;&nbsp; let header = new Header({헤더 내용}) <br />
                &nbsp;&nbsp;&nbsp;&nbsp; let response = await fetch(url, {header : header}) <br />
                &nbsp;&nbsp;&nbsp;&nbsp; let data = await response.json() <br />
                }
            </li>
        </ul>
        <script>
            console.log(1);
            setTimeout(() => {
                console.log(2);
            }, 2000);
            console.log(3);

            // 예제) 다음의 코드가 stack에 어떻게 들어가는지 살펴보자.
            function add(x, y) {
                return x + y;
            }
            function first() {
                let i = add(1, 1);
                console.log(i);
            }
            first();

            /* 
           setTimeOut()         :   스텍에 들어오자마자 바로 백그라운드(대기실)로 보내진다.
           ajax                 :   ajax 포함, 데이터를 받아야 하는 친구들도 백그라운드로 보내진다. 
           addEventListener     :   클릭, 오버, 키다운, ... 언제 실행할 지 모르기 때문에 스텍에 담아두고 있을 수 없다. 백그라운드로 보내진다. 
           
           1. 유알엘을 준비한다.
           2. 헤더를 준비한다.
           3. 서버에 요청한다.(백엔드에 요청한다.) - 시간이 걸리기 때문에 백그라운드로 보내진다. 
           4. 데이터를 보여준다. 
           
                                    async   :   비동기
                                    await   :   대기 
            */
        </script>
    </body>
</html>
